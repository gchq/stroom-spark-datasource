/*
 * Stroom API
 * Various APIs for interacting with Stroom and its data
 *
 * OpenAPI spec version: v1/v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.Query;
import io.swagger.client.model.QueryKey;
import io.swagger.client.model.ResultRequest;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * A request for new search or a follow up request for more data for an existing iterative search
 */
@Schema(description = "A request for new search or a follow up request for more data for an existing iterative search")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-05-13T17:13:49.037+01:00[Europe/London]")
public class SearchRequest {
  @SerializedName("dateTimeLocale")
  private String dateTimeLocale = null;

  @SerializedName("incremental")
  private Boolean incremental = null;

  @SerializedName("key")
  private QueryKey key = null;

  @SerializedName("query")
  private Query query = null;

  @SerializedName("resultRequests")
  private List<ResultRequest> resultRequests = new ArrayList<ResultRequest>();

  @SerializedName("timeout")
  private Long timeout = null;

  public SearchRequest dateTimeLocale(String dateTimeLocale) {
    this.dateTimeLocale = dateTimeLocale;
    return this;
  }

   /**
   * The locale to use when formatting date values in the search results. The value is the string form of a java.time.ZoneId
   * @return dateTimeLocale
  **/
  @Schema(required = true, description = "The locale to use when formatting date values in the search results. The value is the string form of a java.time.ZoneId")
  public String getDateTimeLocale() {
    return dateTimeLocale;
  }

  public void setDateTimeLocale(String dateTimeLocale) {
    this.dateTimeLocale = dateTimeLocale;
  }

  public SearchRequest incremental(Boolean incremental) {
    this.incremental = incremental;
    return this;
  }

   /**
   * If true the response will contain all results found so far, typically no results on the first request. Future requests for the same query key may return more results. Intended for use on longer running searches to allow partial result sets to be returned as soon as they are available rather than waiting for the full result set.
   * @return incremental
  **/
  @Schema(required = true, description = "If true the response will contain all results found so far, typically no results on the first request. Future requests for the same query key may return more results. Intended for use on longer running searches to allow partial result sets to be returned as soon as they are available rather than waiting for the full result set.")
  public Boolean isIncremental() {
    return incremental;
  }

  public void setIncremental(Boolean incremental) {
    this.incremental = incremental;
  }

  public SearchRequest key(QueryKey key) {
    this.key = key;
    return this;
  }

   /**
   * Get key
   * @return key
  **/
  @Schema(required = true, description = "")
  public QueryKey getKey() {
    return key;
  }

  public void setKey(QueryKey key) {
    this.key = key;
  }

  public SearchRequest query(Query query) {
    this.query = query;
    return this;
  }

   /**
   * Get query
   * @return query
  **/
  @Schema(required = true, description = "")
  public Query getQuery() {
    return query;
  }

  public void setQuery(Query query) {
    this.query = query;
  }

  public SearchRequest resultRequests(List<ResultRequest> resultRequests) {
    this.resultRequests = resultRequests;
    return this;
  }

  public SearchRequest addResultRequestsItem(ResultRequest resultRequestsItem) {
    this.resultRequests.add(resultRequestsItem);
    return this;
  }

   /**
   * Get resultRequests
   * @return resultRequests
  **/
  @Schema(required = true, description = "")
  public List<ResultRequest> getResultRequests() {
    return resultRequests;
  }

  public void setResultRequests(List<ResultRequest> resultRequests) {
    this.resultRequests = resultRequests;
  }

  public SearchRequest timeout(Long timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * Set the maximum time (in ms) for the server to wait for a complete result set. The timeout applies to both incremental and non incremental queries, though the behaviour is slightly different. The timeout will make the server wait for which ever comes first out of the query completing or the timeout period being reached. If no value is supplied then for an incremental query a default value of 0 will be used (i.e. returning immediately) and for a non-incremental query the server&#x27;s default timeout period will be used. For an incremental query, if the query has not completed by the end of the timeout period, it will return the currently know results with complete&#x3D;false, however for a non-incremental query it will return no results, complete&#x3D;false and details of the timeout in the error field
   * @return timeout
  **/
  @Schema(description = "Set the maximum time (in ms) for the server to wait for a complete result set. The timeout applies to both incremental and non incremental queries, though the behaviour is slightly different. The timeout will make the server wait for which ever comes first out of the query completing or the timeout period being reached. If no value is supplied then for an incremental query a default value of 0 will be used (i.e. returning immediately) and for a non-incremental query the server's default timeout period will be used. For an incremental query, if the query has not completed by the end of the timeout period, it will return the currently know results with complete=false, however for a non-incremental query it will return no results, complete=false and details of the timeout in the error field")
  public Long getTimeout() {
    return timeout;
  }

  public void setTimeout(Long timeout) {
    this.timeout = timeout;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SearchRequest searchRequest = (SearchRequest) o;
    return Objects.equals(this.dateTimeLocale, searchRequest.dateTimeLocale) &&
        Objects.equals(this.incremental, searchRequest.incremental) &&
        Objects.equals(this.key, searchRequest.key) &&
        Objects.equals(this.query, searchRequest.query) &&
        Objects.equals(this.resultRequests, searchRequest.resultRequests) &&
        Objects.equals(this.timeout, searchRequest.timeout);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dateTimeLocale, incremental, key, query, resultRequests, timeout);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SearchRequest {\n");
    
    sb.append("    dateTimeLocale: ").append(toIndentedString(dateTimeLocale)).append("\n");
    sb.append("    incremental: ").append(toIndentedString(incremental)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    query: ").append(toIndentedString(query)).append("\n");
    sb.append("    resultRequests: ").append(toIndentedString(resultRequests)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
