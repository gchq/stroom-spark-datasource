/*
 * Stroom API
 * Various APIs for interacting with Stroom and its data
 *
 * OpenAPI spec version: v1/v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * IndexField
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-05-13T17:13:49.037+01:00[Europe/London]")
public class IndexField {
  /**
   * Gets or Sets analyzerType
   */
  @JsonAdapter(AnalyzerTypeEnum.Adapter.class)
  public enum AnalyzerTypeEnum {
    KEYWORD("KEYWORD"),
    ALPHA("ALPHA"),
    NUMERIC("NUMERIC"),
    ALPHA_NUMERIC("ALPHA_NUMERIC"),
    WHITESPACE("WHITESPACE"),
    STOP("STOP"),
    STANDARD("STANDARD");

    private String value;

    AnalyzerTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AnalyzerTypeEnum fromValue(String text) {
      for (AnalyzerTypeEnum b : AnalyzerTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AnalyzerTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AnalyzerTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AnalyzerTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return AnalyzerTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("analyzerType")
  private AnalyzerTypeEnum analyzerType = null;

  @SerializedName("caseSensitive")
  private Boolean caseSensitive = null;

  @SerializedName("fieldName")
  private String fieldName = null;

  /**
   * Gets or Sets fieldType
   */
  @JsonAdapter(FieldTypeEnum.Adapter.class)
  public enum FieldTypeEnum {
    ID("ID"),
    BOOLEAN_FIELD("BOOLEAN_FIELD"),
    INTEGER_FIELD("INTEGER_FIELD"),
    LONG_FIELD("LONG_FIELD"),
    FLOAT_FIELD("FLOAT_FIELD"),
    DOUBLE_FIELD("DOUBLE_FIELD"),
    DATE_FIELD("DATE_FIELD"),
    FIELD("FIELD"),
    NUMERIC_FIELD("NUMERIC_FIELD");

    private String value;

    FieldTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static FieldTypeEnum fromValue(String text) {
      for (FieldTypeEnum b : FieldTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<FieldTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FieldTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FieldTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return FieldTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("fieldType")
  private FieldTypeEnum fieldType = null;

  @SerializedName("indexed")
  private Boolean indexed = null;

  @SerializedName("stored")
  private Boolean stored = null;

  @SerializedName("termPositions")
  private Boolean termPositions = null;

  public IndexField analyzerType(AnalyzerTypeEnum analyzerType) {
    this.analyzerType = analyzerType;
    return this;
  }

   /**
   * Get analyzerType
   * @return analyzerType
  **/
  @Schema(description = "")
  public AnalyzerTypeEnum getAnalyzerType() {
    return analyzerType;
  }

  public void setAnalyzerType(AnalyzerTypeEnum analyzerType) {
    this.analyzerType = analyzerType;
  }

  public IndexField caseSensitive(Boolean caseSensitive) {
    this.caseSensitive = caseSensitive;
    return this;
  }

   /**
   * Get caseSensitive
   * @return caseSensitive
  **/
  @Schema(description = "")
  public Boolean isCaseSensitive() {
    return caseSensitive;
  }

  public void setCaseSensitive(Boolean caseSensitive) {
    this.caseSensitive = caseSensitive;
  }

  public IndexField fieldName(String fieldName) {
    this.fieldName = fieldName;
    return this;
  }

   /**
   * Get fieldName
   * @return fieldName
  **/
  @Schema(description = "")
  public String getFieldName() {
    return fieldName;
  }

  public void setFieldName(String fieldName) {
    this.fieldName = fieldName;
  }

  public IndexField fieldType(FieldTypeEnum fieldType) {
    this.fieldType = fieldType;
    return this;
  }

   /**
   * Get fieldType
   * @return fieldType
  **/
  @Schema(description = "")
  public FieldTypeEnum getFieldType() {
    return fieldType;
  }

  public void setFieldType(FieldTypeEnum fieldType) {
    this.fieldType = fieldType;
  }

  public IndexField indexed(Boolean indexed) {
    this.indexed = indexed;
    return this;
  }

   /**
   * Get indexed
   * @return indexed
  **/
  @Schema(description = "")
  public Boolean isIndexed() {
    return indexed;
  }

  public void setIndexed(Boolean indexed) {
    this.indexed = indexed;
  }

  public IndexField stored(Boolean stored) {
    this.stored = stored;
    return this;
  }

   /**
   * Get stored
   * @return stored
  **/
  @Schema(description = "")
  public Boolean isStored() {
    return stored;
  }

  public void setStored(Boolean stored) {
    this.stored = stored;
  }

  public IndexField termPositions(Boolean termPositions) {
    this.termPositions = termPositions;
    return this;
  }

   /**
   * Get termPositions
   * @return termPositions
  **/
  @Schema(description = "")
  public Boolean isTermPositions() {
    return termPositions;
  }

  public void setTermPositions(Boolean termPositions) {
    this.termPositions = termPositions;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IndexField indexField = (IndexField) o;
    return Objects.equals(this.analyzerType, indexField.analyzerType) &&
        Objects.equals(this.caseSensitive, indexField.caseSensitive) &&
        Objects.equals(this.fieldName, indexField.fieldName) &&
        Objects.equals(this.fieldType, indexField.fieldType) &&
        Objects.equals(this.indexed, indexField.indexed) &&
        Objects.equals(this.stored, indexField.stored) &&
        Objects.equals(this.termPositions, indexField.termPositions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(analyzerType, caseSensitive, fieldName, fieldType, indexed, stored, termPositions);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IndexField {\n");
    
    sb.append("    analyzerType: ").append(toIndentedString(analyzerType)).append("\n");
    sb.append("    caseSensitive: ").append(toIndentedString(caseSensitive)).append("\n");
    sb.append("    fieldName: ").append(toIndentedString(fieldName)).append("\n");
    sb.append("    fieldType: ").append(toIndentedString(fieldType)).append("\n");
    sb.append("    indexed: ").append(toIndentedString(indexed)).append("\n");
    sb.append("    stored: ").append(toIndentedString(stored)).append("\n");
    sb.append("    termPositions: ").append(toIndentedString(termPositions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
