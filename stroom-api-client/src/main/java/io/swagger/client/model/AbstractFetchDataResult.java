/*
 * Stroom API
 * Various APIs for interacting with Stroom and its data
 *
 * OpenAPI spec version: v1/v2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.client.model.CountLong;
import io.swagger.client.model.OffsetRange;
import io.swagger.client.model.SourceLocation;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * AbstractFetchDataResult
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2021-05-13T17:13:49.037+01:00[Europe/London]")

public class AbstractFetchDataResult {
  @SerializedName("availableChildStreamTypes")
  private List<String> availableChildStreamTypes = null;

  @SerializedName("classification")
  private String classification = null;

  @SerializedName("feedName")
  private String feedName = null;

  @SerializedName("itemRange")
  private OffsetRange itemRange = null;

  @SerializedName("sourceLocation")
  private SourceLocation sourceLocation = null;

  @SerializedName("streamTypeName")
  private String streamTypeName = null;

  @SerializedName("totalCharacterCount")
  private CountLong totalCharacterCount = null;

  @SerializedName("totalItemCount")
  private CountLong totalItemCount = null;

  @SerializedName("type")
  private String type = null;

  public AbstractFetchDataResult() {
    this.type = this.getClass().getSimpleName();
  }
  public AbstractFetchDataResult availableChildStreamTypes(List<String> availableChildStreamTypes) {
    this.availableChildStreamTypes = availableChildStreamTypes;
    return this;
  }

  public AbstractFetchDataResult addAvailableChildStreamTypesItem(String availableChildStreamTypesItem) {
    if (this.availableChildStreamTypes == null) {
      this.availableChildStreamTypes = new ArrayList<String>();
    }
    this.availableChildStreamTypes.add(availableChildStreamTypesItem);
    return this;
  }

   /**
   * Get availableChildStreamTypes
   * @return availableChildStreamTypes
  **/
  @Schema(description = "")
  public List<String> getAvailableChildStreamTypes() {
    return availableChildStreamTypes;
  }

  public void setAvailableChildStreamTypes(List<String> availableChildStreamTypes) {
    this.availableChildStreamTypes = availableChildStreamTypes;
  }

  public AbstractFetchDataResult classification(String classification) {
    this.classification = classification;
    return this;
  }

   /**
   * Get classification
   * @return classification
  **/
  @Schema(description = "")
  public String getClassification() {
    return classification;
  }

  public void setClassification(String classification) {
    this.classification = classification;
  }

  public AbstractFetchDataResult feedName(String feedName) {
    this.feedName = feedName;
    return this;
  }

   /**
   * Get feedName
   * @return feedName
  **/
  @Schema(description = "")
  public String getFeedName() {
    return feedName;
  }

  public void setFeedName(String feedName) {
    this.feedName = feedName;
  }

  public AbstractFetchDataResult itemRange(OffsetRange itemRange) {
    this.itemRange = itemRange;
    return this;
  }

   /**
   * Get itemRange
   * @return itemRange
  **/
  @Schema(description = "")
  public OffsetRange getItemRange() {
    return itemRange;
  }

  public void setItemRange(OffsetRange itemRange) {
    this.itemRange = itemRange;
  }

  public AbstractFetchDataResult sourceLocation(SourceLocation sourceLocation) {
    this.sourceLocation = sourceLocation;
    return this;
  }

   /**
   * Get sourceLocation
   * @return sourceLocation
  **/
  @Schema(description = "")
  public SourceLocation getSourceLocation() {
    return sourceLocation;
  }

  public void setSourceLocation(SourceLocation sourceLocation) {
    this.sourceLocation = sourceLocation;
  }

  public AbstractFetchDataResult streamTypeName(String streamTypeName) {
    this.streamTypeName = streamTypeName;
    return this;
  }

   /**
   * Get streamTypeName
   * @return streamTypeName
  **/
  @Schema(description = "")
  public String getStreamTypeName() {
    return streamTypeName;
  }

  public void setStreamTypeName(String streamTypeName) {
    this.streamTypeName = streamTypeName;
  }

  public AbstractFetchDataResult totalCharacterCount(CountLong totalCharacterCount) {
    this.totalCharacterCount = totalCharacterCount;
    return this;
  }

   /**
   * Get totalCharacterCount
   * @return totalCharacterCount
  **/
  @Schema(description = "")
  public CountLong getTotalCharacterCount() {
    return totalCharacterCount;
  }

  public void setTotalCharacterCount(CountLong totalCharacterCount) {
    this.totalCharacterCount = totalCharacterCount;
  }

  public AbstractFetchDataResult totalItemCount(CountLong totalItemCount) {
    this.totalItemCount = totalItemCount;
    return this;
  }

   /**
   * Get totalItemCount
   * @return totalItemCount
  **/
  @Schema(description = "")
  public CountLong getTotalItemCount() {
    return totalItemCount;
  }

  public void setTotalItemCount(CountLong totalItemCount) {
    this.totalItemCount = totalItemCount;
  }

  public AbstractFetchDataResult type(String type) {
    this.type = type;
    return this;
  }

   /**
   * Get type
   * @return type
  **/
  @Schema(required = true, description = "")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AbstractFetchDataResult abstractFetchDataResult = (AbstractFetchDataResult) o;
    return Objects.equals(this.availableChildStreamTypes, abstractFetchDataResult.availableChildStreamTypes) &&
        Objects.equals(this.classification, abstractFetchDataResult.classification) &&
        Objects.equals(this.feedName, abstractFetchDataResult.feedName) &&
        Objects.equals(this.itemRange, abstractFetchDataResult.itemRange) &&
        Objects.equals(this.sourceLocation, abstractFetchDataResult.sourceLocation) &&
        Objects.equals(this.streamTypeName, abstractFetchDataResult.streamTypeName) &&
        Objects.equals(this.totalCharacterCount, abstractFetchDataResult.totalCharacterCount) &&
        Objects.equals(this.totalItemCount, abstractFetchDataResult.totalItemCount) &&
        Objects.equals(this.type, abstractFetchDataResult.type);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableChildStreamTypes, classification, feedName, itemRange, sourceLocation, streamTypeName, totalCharacterCount, totalItemCount, type);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AbstractFetchDataResult {\n");
    
    sb.append("    availableChildStreamTypes: ").append(toIndentedString(availableChildStreamTypes)).append("\n");
    sb.append("    classification: ").append(toIndentedString(classification)).append("\n");
    sb.append("    feedName: ").append(toIndentedString(feedName)).append("\n");
    sb.append("    itemRange: ").append(toIndentedString(itemRange)).append("\n");
    sb.append("    sourceLocation: ").append(toIndentedString(sourceLocation)).append("\n");
    sb.append("    streamTypeName: ").append(toIndentedString(streamTypeName)).append("\n");
    sb.append("    totalCharacterCount: ").append(toIndentedString(totalCharacterCount)).append("\n");
    sb.append("    totalItemCount: ").append(toIndentedString(totalItemCount)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
